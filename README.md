# test1
//uva10019
/*一位來自墨西哥蒙特瑞技術研究學院(ITESM Campus Monterrey)的學生想發表一種新的數值加密演算法。
演算法步驟如下：

1. 讀入一個整數N，N為欲加密的數字：N = 265
2. 將N當作十進位的數值：X1 = 265(decimal)
3. 把X1由十進制轉為二進制：X1 = 100001001(binary)
4. 計算二進制的X1有幾個1：b1 = 3
5. 把N當作十六進位數值：X2 = 265(hexadecimal)
6. 把X2由十六進制轉為二進制：X2 = 1001100101(binary)
7. 計算二進制的X2有幾個1：b2 = 5
8. 最後的編碼為N xor (b1*b2)：265 xor (3*5) = 262

這位學生並未通過這次的計算機組識考試，所以他請求校方在ACM的試題上出一題計算共有幾個位元1的題目，好讓他能順利發表他的數值加密演算法。
你必須寫一個程式能讀入一個整數，然後輸出該整數的b1, b2值。

輸入說明
第一行包含一個數字T (0 < T ? 1000)，代表有幾組測資。
接下來的T行，每行包含一個數字N (decimal)(0 < N ? 9999)，N代表學生要加密的數字。
輸出說明
對於每組測資，輸出數字b1和b2，b1和b2請用空白分隔。

*/ 

#include <iostream>
using namespace std;

int main()
{
    int n,in1,cn1;
    
    cin>>n;//輸入測資數量 
    while(n--) 
    {
        int b1=0,b2=0;
        cin>>in1;//輸入測資
        cn1=in1;
        
        while(cn1>0)//十進制轉二進制 
        {
            if(cn1%2==1)//利用短除法 
            {
                b1=b1+1;//計算有幾個1 
            }
            cn1=cn1/2;
        }
        
        cn1=in1;
        while(cn1>0)//十六進制轉二進制 
        {           //利用1個位數轉4個位數的方法 
            int temp=cn1%10;//先取最左邊的位數 
            while(temp>0)//再利用10進位轉2進位的方法 
            {             
                if(temp%2==1)
                {
                    b2=b2+1;
                }
                
                temp=temp/2;
            }
            cn1=cn1/10;
            
        }
        
        cout<<b1<<" "<<b2<<endl;//輸出 
    }
    return 0;
}

